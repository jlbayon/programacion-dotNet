# Ejercicios Resueltos: Genéricos en C#

En estos ejercicios practicaremos el uso de **genéricos** en C#, creando clases, métodos e interfaces que trabajan con cualquier tipo de datos.

---

## Ejercicio 1: Caja genérica
**Enunciado:**  
Crea una clase genérica `Caja<T>` que pueda guardar un objeto de cualquier tipo.  
Agrega métodos `Guardar(T valor)` y `Obtener()`.  
Prueba con un entero y con un string.

```csharp
public class Caja<T>
{
    private T contenido;

    public void Guardar(T valor)
    {
        contenido = valor;
    }

    public T Obtener()
    {
        return contenido;
    }
}

class Program
{
    static void Main()
    {
        Caja<int> cajaEntero = new Caja<int>();
        cajaEntero.Guardar(10);
        Console.WriteLine(cajaEntero.Obtener());

        Caja<string> cajaString = new Caja<string>();
        cajaString.Guardar("Hola");
        Console.WriteLine(cajaString.Obtener());
    }
}
```

---

## Ejercicio 2: Par genérico
**Enunciado:**  
Crea una clase genérica `Par<T1, T2>` que almacene dos valores.  
Crea un objeto con un `string` y un `int`.

```csharp
public class Par<T1, T2>
{
    public T1 Primero { get; set; }
    public T2 Segundo { get; set; }
}

class Program
{
    static void Main()
    {
        Par<string, int> par = new Par<string, int> { Primero = "Edad", Segundo = 30 };
        Console.WriteLine($"{par.Primero}: {par.Segundo}");
    }
}
```

---

## Ejercicio 3: Lista genérica simple
**Enunciado:**  
Crea una clase genérica `ListaSimple<T>` con un array interno.  
Agrega métodos `Agregar(T valor)` y `MostrarTodos()`.  
Prueba con enteros.

```csharp
public class ListaSimple<T>
{
    private List<T> elementos = new List<T>();

    public void Agregar(T valor)
    {
        elementos.Add(valor);
    }

    public void MostrarTodos()
    {
        foreach (var e in elementos)
        {
            Console.WriteLine(e);
        }
    }
}

class Program
{
    static void Main()
    {
        ListaSimple<int> lista = new ListaSimple<int>();
        lista.Agregar(1);
        lista.Agregar(2);
        lista.Agregar(3);

        lista.MostrarTodos();
    }
}
```

---

## Ejercicio 4: Método genérico
**Enunciado:**  
Crea un método genérico `Intercambiar<T>(ref T a, ref T b)` que intercambie dos valores.  
Prueba con enteros y con strings.

```csharp
class Utilidades
{
    public static void Intercambiar<T>(ref T a, ref T b)
    {
        T temp = a;
        a = b;
        b = temp;
    }
}

class Program
{
    static void Main()
    {
        int x = 1, y = 2;
        Utilidades.Intercambiar(ref x, ref y);
        Console.WriteLine($"x={x}, y={y}");

        string s1 = "Hola", s2 = "Mundo";
        Utilidades.Intercambiar(ref s1, ref s2);
        Console.WriteLine($"s1={s1}, s2={s2}");
    }
}
```

---

## Ejercicio 5: Pila genérica
**Enunciado:**  
Crea una clase genérica `Pila<T>` con métodos `Push(T valor)` y `Pop()`.  
Prueba con enteros.

```csharp
public class Pila<T>
{
    private Stack<T> pila = new Stack<T>();

    public void Push(T valor)
    {
        pila.Push(valor);
    }

    public T Pop()
    {
        return pila.Pop();
    }
}

class Program
{
    static void Main()
    {
        Pila<int> pila = new Pila<int>();
        pila.Push(10);
        pila.Push(20);
        Console.WriteLine(pila.Pop());
        Console.WriteLine(pila.Pop());
    }
}
```

---

## Ejercicio 6: Comparador genérico
**Enunciado:**  
Crea una clase estática `Comparador` con un método genérico `EsIgual<T>(T a, T b)` que devuelva true si son iguales.  
Prueba con enteros y strings.

```csharp
public static class Comparador
{
    public static bool EsIgual<T>(T a, T b)
    {
        return a.Equals(b);
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine(Comparador.EsIgual(5, 5));
        Console.WriteLine(Comparador.EsIgual("Hola", "Mundo"));
    }
}
```

---

## Ejercicio 7: Restricción genérica
**Enunciado:**  
Crea una clase genérica `Repositorio<T>` que acepte solo tipos que tengan un constructor sin parámetros (`where T : new()`).  
Agrega un método `Crear()` que devuelva una nueva instancia de T.

```csharp
public class Repositorio<T> where T : new()
{
    public T Crear()
    {
        return new T();
    }
}

public class Persona
{
    public string Nombre = "Sin nombre";
}

class Program
{
    static void Main()
    {
        Repositorio<Persona> repo = new Repositorio<Persona>();
        Persona p = repo.Crear();
        Console.WriteLine(p.Nombre);
    }
}
```

---

## Ejercicio 8: Diccionario genérico
**Enunciado:**  
Crea una clase `DiccionarioSimple<K, V>` que use un `Dictionary<K, V>`.  
Agrega métodos `Agregar(K clave, V valor)` y `Obtener(K clave)`.  
Prueba con claves string y valores int.

```csharp
public class DiccionarioSimple<K, V>
{
    private Dictionary<K, V> dict = new Dictionary<K, V>();

    public void Agregar(K clave, V valor)
    {
        dict[clave] = valor;
    }

    public V Obtener(K clave)
    {
        return dict[clave];
    }
}

class Program
{
    static void Main()
    {
        DiccionarioSimple<string, int> dic = new DiccionarioSimple<string, int>();
        dic.Agregar("Uno", 1);
        dic.Agregar("Dos", 2);

        Console.WriteLine(dic.Obtener("Uno"));
    }
}
```

---

## Ejercicio 9: Interfaz genérica
**Enunciado:**  
Crea una interfaz genérica `IContenedor<T>` con métodos `Agregar(T item)` y `Obtener(int index)`.  
Crea una clase `ContenedorLista<T>` que la implemente.  
Prueba con strings.

```csharp
public interface IContenedor<T>
{
    void Agregar(T item);
    T Obtener(int index);
}

public class ContenedorLista<T> : IContenedor<T>
{
    private List<T> lista = new List<T>();

    public void Agregar(T item)
    {
        lista.Add(item);
    }

    public T Obtener(int index)
    {
        return lista[index];
    }
}

class Program
{
    static void Main()
    {
        IContenedor<string> contenedor = new ContenedorLista<string>();
        contenedor.Agregar("Hola");
        contenedor.Agregar("Mundo");

        Console.WriteLine(contenedor.Obtener(1));
    }
}
```

---

## Ejercicio 10: Método genérico con restricción
**Enunciado:**  
Crea un método genérico `Mayor<T>(T a, T b)` que devuelva el mayor usando `IComparable<T>`.  
Prueba con enteros y strings.

```csharp
public static class Util
{
    public static T Mayor<T>(T a, T b) where T : IComparable<T>
    {
        return a.CompareTo(b) > 0 ? a : b;
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine(Util.Mayor(5, 8));
        Console.WriteLine(Util.Mayor("Hola", "Adiós"));
    }
}
```

---
